"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fs_1 = __importDefault(require("node:fs"));
const node_process_1 = __importDefault(require("node:process"));
function main(args) {
    if (args.length !== 1) {
        console.log("Usage: generate_ast <output directory>");
        return node_process_1.default.exit(64);
    }
    const outputDir = args[0];
    defineAst(outputDir, "Expr", [
        "Binary   + left: Expr, operator: Token, right: Expr",
        "Grouping + expression: Expr",
        "Literal  + value: object",
        "Unary    + operator: Token, right: Expr",
    ]);
}
function defineAst(outputDir, baseName, types) {
    const path = `${outputDir}/${baseName}.ts`;
    let fileContent = `// Auto-generated by Lox. Do not edit.\n`;
    fileContent += `\n`;
    fileContent += `import { Token } from "tokens/token"`;
    fileContent += `\n`;
    fileContent += `export abstract class ${baseName} {}\n`;
    fileContent += `\n`;
    fileContent += `export interface Visitor<R> {\n`;
    types.forEach((type) => {
        const className = type.split("+")[0].trim();
        fileContent += `  visit${className}${baseName}(${baseName.toLowerCase()}: ${className}): R;\n`;
    });
    fileContent += `}\n`;
    fileContent += `\n`;
    types.forEach((type) => {
        const className = type.split("+")[0].trim();
        const fields = type.split("+")[1].trim();
        fileContent += defineType(baseName, className, fields);
        fileContent += `\n`;
    });
    node_fs_1.default.writeFileSync(path, fileContent, { encoding: "utf-8" });
    console.log(`Successfully generated AST for ${baseName} at ${path}`);
}
function defineType(baseName, className, fieldList) {
    const fields = fieldList.split(", ");
    const constructorParams = fields.map((field) => `public ${field}`).join(", ");
    const visitorMethod = `  accept<R>(visitor: Visitor<R>): R {\n    return visitor.visit${className}${baseName}(this);\n  }`;
    return `export class ${className} extends ${baseName} {
  constructor(${constructorParams}) {
    super();
  }

${visitorMethod}
}`;
}
main(["/Users/perepalacin/Documents/pere-repos/crafting-compilers/typescript/src/expression"]);
//# sourceMappingURL=generate-ast.js.map